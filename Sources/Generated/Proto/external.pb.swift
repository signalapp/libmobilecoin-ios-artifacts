// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: external.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2018-2021 The MobileCoin Foundation

// MUST BE KEPT IN SYNC WITH RUST CODE!

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

//// A Ristretto private key.
public struct External_RistrettoPrivate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// A 32-byte compressed Ristretto curve point (public key)
public struct External_CompressedRistretto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// An Ed25519 public key, for validating signatures.
public struct External_Ed25519Public {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// An Ed25519 signature object
public struct External_Ed25519Signature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// Complete AccountKey, containing the pair of secret keys, which can be used
//// for spending, and optionally some Fog related info that is used to form
//// public addresses for accounts that sign up with Fog service.
////
//// This matches the Rust `transaction::AccountKey` struct.
public struct External_AccountKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Private key 'a' used for view-key matching.
  public var viewPrivateKey: External_RistrettoPrivate {
    get {return _viewPrivateKey ?? External_RistrettoPrivate()}
    set {_viewPrivateKey = newValue}
  }
  /// Returns true if `viewPrivateKey` has been explicitly set.
  public var hasViewPrivateKey: Bool {return self._viewPrivateKey != nil}
  /// Clears the value of `viewPrivateKey`. Subsequent reads from it will return its default value.
  public mutating func clearViewPrivateKey() {self._viewPrivateKey = nil}

  //// Private key `b` used for spending.
  public var spendPrivateKey: External_RistrettoPrivate {
    get {return _spendPrivateKey ?? External_RistrettoPrivate()}
    set {_spendPrivateKey = newValue}
  }
  /// Returns true if `spendPrivateKey` has been explicitly set.
  public var hasSpendPrivateKey: Bool {return self._spendPrivateKey != nil}
  /// Clears the value of `spendPrivateKey`. Subsequent reads from it will return its default value.
  public mutating func clearSpendPrivateKey() {self._spendPrivateKey = nil}

  //// Optional url of fog report server.
  //// Empty string when not in use, i.e. for accounts that don't have fog service.
  public var fogReportURL: String = String()

  //// Optional fog report id.
  //// The fog report server may serve multiple reports, this id disambiguates
  //// which one to use when sending to this account.
  public var fogReportID: String = String()

  //// Optional fog authority subjectPublicKeyInfo.
  //// Empty when not in use.
  public var fogAuthoritySpki: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _viewPrivateKey: External_RistrettoPrivate? = nil
  fileprivate var _spendPrivateKey: External_RistrettoPrivate? = nil
}

//// A public address, used to identify recipients.
public struct External_PublicAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// View public key
  public var viewPublicKey: External_CompressedRistretto {
    get {return _viewPublicKey ?? External_CompressedRistretto()}
    set {_viewPublicKey = newValue}
  }
  /// Returns true if `viewPublicKey` has been explicitly set.
  public var hasViewPublicKey: Bool {return self._viewPublicKey != nil}
  /// Clears the value of `viewPublicKey`. Subsequent reads from it will return its default value.
  public mutating func clearViewPublicKey() {self._viewPublicKey = nil}

  //// Spend public key
  public var spendPublicKey: External_CompressedRistretto {
    get {return _spendPublicKey ?? External_CompressedRistretto()}
    set {_spendPublicKey = newValue}
  }
  /// Returns true if `spendPublicKey` has been explicitly set.
  public var hasSpendPublicKey: Bool {return self._spendPublicKey != nil}
  /// Clears the value of `spendPublicKey`. Subsequent reads from it will return its default value.
  public mutating func clearSpendPublicKey() {self._spendPublicKey = nil}

  //// Optional url of fog report server.
  //// Empty string when not in use, i.e. for accounts that don't have fog service.
  //// Indicates the place at which the fog report server should be contacted.
  public var fogReportURL: String = String()

  //// Optional fog report id.
  //// The fog report server may serve multiple reports, this id disambiguates
  //// which one to use when sending to this account.
  public var fogReportID: String = String()

  //// View key signature over the fog authority subjectPublicKeyInfo.
  ////
  //// This must be parseable as a RistrettoSignature.
  public var fogAuthoritySig: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _viewPublicKey: External_CompressedRistretto? = nil
  fileprivate var _spendPublicKey: External_CompressedRistretto? = nil
}

//// A KDF can be used to stretch a 32 byte secret into multiple secret private keys.
//// The RootIdentity is a compact form of a user's account key, if it has been
//// derived in this way. This may be useful for e.g. paper wallets.
public struct External_RootIdentity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The root entropy used to derive cryptonote private keys for this account
  public var rootEntropy: External_RootEntropy {
    get {return _rootEntropy ?? External_RootEntropy()}
    set {_rootEntropy = newValue}
  }
  /// Returns true if `rootEntropy` has been explicitly set.
  public var hasRootEntropy: Bool {return self._rootEntropy != nil}
  /// Clears the value of `rootEntropy`. Subsequent reads from it will return its default value.
  public mutating func clearRootEntropy() {self._rootEntropy = nil}

  //// Optional url of fog report server, same as in AccountKey
  public var fogReportURL: String = String()

  //// Optional fog report id, same as in AccountKey
  public var fogReportID: String = String()

  //// Optional fog authority subjectPublicKeyInfo.
  //// Empty when not in use.
  public var fogAuthoritySpki: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _rootEntropy: External_RootEntropy? = nil
}

//// A 32 byte secret used as input key material to derive private keys
public struct External_RootEntropy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// A ViewKey is a reduced AccountKey -- it contains the private key necessary to
//// view your transactions and see the amounts, but not to send new transactions.
//// This concept is part of Cryptonote.
//// In Mobilecoin, all public addresses correspond to subaddresses, and often
//// the "default subaddress" is used.
//// The ViewKey similarly corresponds to a particular subaddress.
public struct External_ViewKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The view-private-key of the account. This enables to check if a transaction
  //// corresponds to this subaddress, and to interact with fog.
  public var viewPrivateKey: External_RistrettoPrivate {
    get {return _viewPrivateKey ?? External_RistrettoPrivate()}
    set {_viewPrivateKey = newValue}
  }
  /// Returns true if `viewPrivateKey` has been explicitly set.
  public var hasViewPrivateKey: Bool {return self._viewPrivateKey != nil}
  /// Clears the value of `viewPrivateKey`. Subsequent reads from it will return its default value.
  public mutating func clearViewPrivateKey() {self._viewPrivateKey = nil}

  //// The spend public key of the account.
  //// This value also appears in the public address.
  public var spendPublicKey: External_CompressedRistretto {
    get {return _spendPublicKey ?? External_CompressedRistretto()}
    set {_spendPublicKey = newValue}
  }
  /// Returns true if `spendPublicKey` has been explicitly set.
  public var hasSpendPublicKey: Bool {return self._spendPublicKey != nil}
  /// Clears the value of `spendPublicKey`. Subsequent reads from it will return its default value.
  public mutating func clearSpendPublicKey() {self._spendPublicKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _viewPrivateKey: External_RistrettoPrivate? = nil
  fileprivate var _spendPublicKey: External_CompressedRistretto? = nil
}

//// A 32-byte scalar associated to the ristretto group.
//// This is the same as RistrettoPrivate, but they are used in different places.
//// TODO: MC-1605 Consider to factor out this type, or just this proto message.
public struct External_CurveScalar {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// A 32-byte mobilecoin transaction key image.
public struct External_KeyImage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct External_Range {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var from: UInt64 = 0

  public var to: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct External_TxOutMembershipHash {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct External_TxOutMembershipElement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var range: External_Range {
    get {return _range ?? External_Range()}
    set {_range = newValue}
  }
  /// Returns true if `range` has been explicitly set.
  public var hasRange: Bool {return self._range != nil}
  /// Clears the value of `range`. Subsequent reads from it will return its default value.
  public mutating func clearRange() {self._range = nil}

  public var hash: External_TxOutMembershipHash {
    get {return _hash ?? External_TxOutMembershipHash()}
    set {_hash = newValue}
  }
  /// Returns true if `hash` has been explicitly set.
  public var hasHash: Bool {return self._hash != nil}
  /// Clears the value of `hash`. Subsequent reads from it will return its default value.
  public mutating func clearHash() {self._hash = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _range: External_Range? = nil
  fileprivate var _hash: External_TxOutMembershipHash? = nil
}

public struct External_TxOutMembershipProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var index: UInt64 = 0

  public var highestIndex: UInt64 = 0

  public var elements: [External_TxOutMembershipElement] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A hash of the shared secret of a transaction output.
///
/// Can be used by the recipient of a transaction output to verify that the
/// bearer of this number knew the shared secret of the transaction output,
/// thereby providing evidence that they are the sender.
public struct External_TxOutConfirmationNumber {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Amount.
public struct External_Amount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A Pedersen commitment `v*G + s*H`
  public var commitment: External_CompressedRistretto {
    get {return _commitment ?? External_CompressedRistretto()}
    set {_commitment = newValue}
  }
  /// Returns true if `commitment` has been explicitly set.
  public var hasCommitment: Bool {return self._commitment != nil}
  /// Clears the value of `commitment`. Subsequent reads from it will return its default value.
  public mutating func clearCommitment() {self._commitment = nil}

  /// `masked_value = value XOR_8 Blake2B("value_mask" || shared_secret)`
  public var maskedValue: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _commitment: External_CompressedRistretto? = nil
}

/// The bytes of encrypted fog hint
public struct External_EncryptedFogHint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The bytes of encrypted memo
public struct External_EncryptedMemo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A Transaction Output.
public struct External_TxOut {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Amount.
  public var amount: External_Amount {
    get {return _amount ?? External_Amount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  public var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  public mutating func clearAmount() {self._amount = nil}

  /// Public key.
  public var targetKey: External_CompressedRistretto {
    get {return _targetKey ?? External_CompressedRistretto()}
    set {_targetKey = newValue}
  }
  /// Returns true if `targetKey` has been explicitly set.
  public var hasTargetKey: Bool {return self._targetKey != nil}
  /// Clears the value of `targetKey`. Subsequent reads from it will return its default value.
  public mutating func clearTargetKey() {self._targetKey = nil}

  /// Public key.
  public var publicKey: External_CompressedRistretto {
    get {return _publicKey ?? External_CompressedRistretto()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  public var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  public mutating func clearPublicKey() {self._publicKey = nil}

  /// Encrypted fog hint payload.
  /// This is an mc-crypto-box cryptogram for the fog ingest server,
  /// or a random cryptogram indistinguishable from a real one.
  public var eFogHint: External_EncryptedFogHint {
    get {return _eFogHint ?? External_EncryptedFogHint()}
    set {_eFogHint = newValue}
  }
  /// Returns true if `eFogHint` has been explicitly set.
  public var hasEFogHint: Bool {return self._eFogHint != nil}
  /// Clears the value of `eFogHint`. Subsequent reads from it will return its default value.
  public mutating func clearEFogHint() {self._eFogHint = nil}

  /// Encrypted memo
  public var eMemo: External_EncryptedMemo {
    get {return _eMemo ?? External_EncryptedMemo()}
    set {_eMemo = newValue}
  }
  /// Returns true if `eMemo` has been explicitly set.
  public var hasEMemo: Bool {return self._eMemo != nil}
  /// Clears the value of `eMemo`. Subsequent reads from it will return its default value.
  public mutating func clearEMemo() {self._eMemo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _amount: External_Amount? = nil
  fileprivate var _targetKey: External_CompressedRistretto? = nil
  fileprivate var _publicKey: External_CompressedRistretto? = nil
  fileprivate var _eFogHint: External_EncryptedFogHint? = nil
  fileprivate var _eMemo: External_EncryptedMemo? = nil
}

public struct External_TxIn {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// "Ring" of inputs, one of which is actually being spent.
  public var ring: [External_TxOut] = []

  /// Proof that each TxOut in `ring` is in the ledger.
  public var proofs: [External_TxOutMembershipProof] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A transaction that a client submits to consensus
public struct External_TxPrefix {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Transaction inputs.
  public var inputs: [External_TxIn] = []

  /// Transaction outputs.
  public var outputs: [External_TxOut] = []

  /// Fee paid to the foundation for this transaction
  public var fee: UInt64 = 0

  /// The block index at which this transaction is no longer valid.
  public var tombstoneBlock: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct External_RingMLSAG {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cZero: External_CurveScalar {
    get {return _cZero ?? External_CurveScalar()}
    set {_cZero = newValue}
  }
  /// Returns true if `cZero` has been explicitly set.
  public var hasCZero: Bool {return self._cZero != nil}
  /// Clears the value of `cZero`. Subsequent reads from it will return its default value.
  public mutating func clearCZero() {self._cZero = nil}

  public var responses: [External_CurveScalar] = []

  public var keyImage: External_KeyImage {
    get {return _keyImage ?? External_KeyImage()}
    set {_keyImage = newValue}
  }
  /// Returns true if `keyImage` has been explicitly set.
  public var hasKeyImage: Bool {return self._keyImage != nil}
  /// Clears the value of `keyImage`. Subsequent reads from it will return its default value.
  public mutating func clearKeyImage() {self._keyImage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cZero: External_CurveScalar? = nil
  fileprivate var _keyImage: External_KeyImage? = nil
}

public struct External_SignatureRctBulletproofs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ringSignatures: [External_RingMLSAG] = []

  public var pseudoOutputCommitments: [External_CompressedRistretto] = []

  public var rangeProofs: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct External_Tx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The actual contents of the transaction.
  public var prefix: External_TxPrefix {
    get {return _prefix ?? External_TxPrefix()}
    set {_prefix = newValue}
  }
  /// Returns true if `prefix` has been explicitly set.
  public var hasPrefix: Bool {return self._prefix != nil}
  /// Clears the value of `prefix`. Subsequent reads from it will return its default value.
  public mutating func clearPrefix() {self._prefix = nil}

  /// The RingCT signature on the prefix.
  public var signature: External_SignatureRctBulletproofs {
    get {return _signature ?? External_SignatureRctBulletproofs()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _prefix: External_TxPrefix? = nil
  fileprivate var _signature: External_SignatureRctBulletproofs? = nil
}

public struct External_TxHash {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Hash of a single transaction.
  public var hash: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Given to the recipient of a transaction output by the sender so that the
/// recipient may verify that the other party is indeed the sender.
///
/// Often given to the recipient before the transaction is finalized so that
/// the recipient may know to anticipate the arrival of a transaction output,
/// as well as know who it's from, when to consider it as having surpassed
/// the tombstone block, and the expected amount of the output.
public struct External_Receipt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Public key of the TxOut.
  public var publicKey: External_CompressedRistretto {
    get {return _publicKey ?? External_CompressedRistretto()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  public var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  public mutating func clearPublicKey() {self._publicKey = nil}

  /// Confirmation number of the TxOut.
  public var confirmation: External_TxOutConfirmationNumber {
    get {return _confirmation ?? External_TxOutConfirmationNumber()}
    set {_confirmation = newValue}
  }
  /// Returns true if `confirmation` has been explicitly set.
  public var hasConfirmation: Bool {return self._confirmation != nil}
  /// Clears the value of `confirmation`. Subsequent reads from it will return its default value.
  public mutating func clearConfirmation() {self._confirmation = nil}

  /// Tombstone block of the Tx that produced the TxOut.
  /// Note: This value is self-reported by the sender and is unverifiable.
  public var tombstoneBlock: UInt64 = 0

  /// Amount of the TxOut.
  /// Note: This value is self-reported by the sender and is unverifiable.
  public var amount: External_Amount {
    get {return _amount ?? External_Amount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  public var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  public mutating func clearAmount() {self._amount = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _publicKey: External_CompressedRistretto? = nil
  fileprivate var _confirmation: External_TxOutConfirmationNumber? = nil
  fileprivate var _amount: External_Amount? = nil
}

//// The signature over an IAS JSON reponse, created by Intel
public struct External_VerificationSignature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var contents: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// The IAS verification report response encoded as a protocol buffer
public struct External_VerificationReport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The IAS-generated signature over the response string
  public var sig: External_VerificationSignature {
    get {return _sig ?? External_VerificationSignature()}
    set {_sig = newValue}
  }
  /// Returns true if `sig` has been explicitly set.
  public var hasSig: Bool {return self._sig != nil}
  /// Clears the value of `sig`. Subsequent reads from it will return its default value.
  public mutating func clearSig() {self._sig = nil}

  //// A list of byte strings representing the DER-encoded certificate
  //// chain provided by IAS.
  public var chain: [Data] = []

  //// The raw report body JSON, as a byte sequence
  public var httpBody: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sig: External_VerificationSignature? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "external"

extension External_RistrettoPrivate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RistrettoPrivate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_RistrettoPrivate, rhs: External_RistrettoPrivate) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_CompressedRistretto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompressedRistretto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_CompressedRistretto, rhs: External_CompressedRistretto) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_Ed25519Public: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Ed25519Public"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_Ed25519Public, rhs: External_Ed25519Public) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_Ed25519Signature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Ed25519Signature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_Ed25519Signature, rhs: External_Ed25519Signature) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_AccountKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "view_private_key"),
    2: .standard(proto: "spend_private_key"),
    3: .standard(proto: "fog_report_url"),
    4: .standard(proto: "fog_report_id"),
    5: .standard(proto: "fog_authority_spki"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._viewPrivateKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spendPrivateKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fogReportURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fogReportID) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.fogAuthoritySpki) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._viewPrivateKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._spendPrivateKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.fogReportURL.isEmpty {
      try visitor.visitSingularStringField(value: self.fogReportURL, fieldNumber: 3)
    }
    if !self.fogReportID.isEmpty {
      try visitor.visitSingularStringField(value: self.fogReportID, fieldNumber: 4)
    }
    if !self.fogAuthoritySpki.isEmpty {
      try visitor.visitSingularBytesField(value: self.fogAuthoritySpki, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_AccountKey, rhs: External_AccountKey) -> Bool {
    if lhs._viewPrivateKey != rhs._viewPrivateKey {return false}
    if lhs._spendPrivateKey != rhs._spendPrivateKey {return false}
    if lhs.fogReportURL != rhs.fogReportURL {return false}
    if lhs.fogReportID != rhs.fogReportID {return false}
    if lhs.fogAuthoritySpki != rhs.fogAuthoritySpki {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_PublicAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublicAddress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "view_public_key"),
    2: .standard(proto: "spend_public_key"),
    3: .standard(proto: "fog_report_url"),
    4: .standard(proto: "fog_report_id"),
    5: .standard(proto: "fog_authority_sig"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._viewPublicKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spendPublicKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fogReportURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fogReportID) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.fogAuthoritySig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._viewPublicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._spendPublicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.fogReportURL.isEmpty {
      try visitor.visitSingularStringField(value: self.fogReportURL, fieldNumber: 3)
    }
    if !self.fogReportID.isEmpty {
      try visitor.visitSingularStringField(value: self.fogReportID, fieldNumber: 4)
    }
    if !self.fogAuthoritySig.isEmpty {
      try visitor.visitSingularBytesField(value: self.fogAuthoritySig, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_PublicAddress, rhs: External_PublicAddress) -> Bool {
    if lhs._viewPublicKey != rhs._viewPublicKey {return false}
    if lhs._spendPublicKey != rhs._spendPublicKey {return false}
    if lhs.fogReportURL != rhs.fogReportURL {return false}
    if lhs.fogReportID != rhs.fogReportID {return false}
    if lhs.fogAuthoritySig != rhs.fogAuthoritySig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_RootIdentity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RootIdentity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_entropy"),
    2: .standard(proto: "fog_report_url"),
    3: .standard(proto: "fog_report_id"),
    5: .standard(proto: "fog_authority_spki"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rootEntropy) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fogReportURL) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fogReportID) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.fogAuthoritySpki) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rootEntropy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.fogReportURL.isEmpty {
      try visitor.visitSingularStringField(value: self.fogReportURL, fieldNumber: 2)
    }
    if !self.fogReportID.isEmpty {
      try visitor.visitSingularStringField(value: self.fogReportID, fieldNumber: 3)
    }
    if !self.fogAuthoritySpki.isEmpty {
      try visitor.visitSingularBytesField(value: self.fogAuthoritySpki, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_RootIdentity, rhs: External_RootIdentity) -> Bool {
    if lhs._rootEntropy != rhs._rootEntropy {return false}
    if lhs.fogReportURL != rhs.fogReportURL {return false}
    if lhs.fogReportID != rhs.fogReportID {return false}
    if lhs.fogAuthoritySpki != rhs.fogAuthoritySpki {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_RootEntropy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RootEntropy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_RootEntropy, rhs: External_RootEntropy) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_ViewKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ViewKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "view_private_key"),
    2: .standard(proto: "spend_public_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._viewPrivateKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spendPublicKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._viewPrivateKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._spendPublicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_ViewKey, rhs: External_ViewKey) -> Bool {
    if lhs._viewPrivateKey != rhs._viewPrivateKey {return false}
    if lhs._spendPublicKey != rhs._spendPublicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_CurveScalar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CurveScalar"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_CurveScalar, rhs: External_CurveScalar) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_KeyImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeyImage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_KeyImage, rhs: External_KeyImage) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_Range: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Range"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.from) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.to) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.from != 0 {
      try visitor.visitSingularUInt64Field(value: self.from, fieldNumber: 1)
    }
    if self.to != 0 {
      try visitor.visitSingularUInt64Field(value: self.to, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_Range, rhs: External_Range) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.to != rhs.to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_TxOutMembershipHash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TxOutMembershipHash"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_TxOutMembershipHash, rhs: External_TxOutMembershipHash) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_TxOutMembershipElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TxOutMembershipElement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "range"),
    2: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._range) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._hash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._range {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._hash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_TxOutMembershipElement, rhs: External_TxOutMembershipElement) -> Bool {
    if lhs._range != rhs._range {return false}
    if lhs._hash != rhs._hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_TxOutMembershipProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TxOutMembershipProof"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .standard(proto: "highest_index"),
    3: .same(proto: "elements"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.highestIndex) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.elements) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt64Field(value: self.index, fieldNumber: 1)
    }
    if self.highestIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.highestIndex, fieldNumber: 2)
    }
    if !self.elements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elements, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_TxOutMembershipProof, rhs: External_TxOutMembershipProof) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.highestIndex != rhs.highestIndex {return false}
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_TxOutConfirmationNumber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TxOutConfirmationNumber"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_TxOutConfirmationNumber, rhs: External_TxOutConfirmationNumber) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_Amount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Amount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "commitment"),
    2: .standard(proto: "masked_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commitment) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.maskedValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commitment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.maskedValue != 0 {
      try visitor.visitSingularFixed64Field(value: self.maskedValue, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_Amount, rhs: External_Amount) -> Bool {
    if lhs._commitment != rhs._commitment {return false}
    if lhs.maskedValue != rhs.maskedValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_EncryptedFogHint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EncryptedFogHint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_EncryptedFogHint, rhs: External_EncryptedFogHint) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_EncryptedMemo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EncryptedMemo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_EncryptedMemo, rhs: External_EncryptedMemo) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_TxOut: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TxOut"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .standard(proto: "target_key"),
    3: .standard(proto: "public_key"),
    4: .standard(proto: "e_fog_hint"),
    5: .standard(proto: "e_memo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._targetKey) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._eFogHint) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._eMemo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._targetKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._eFogHint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._eMemo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_TxOut, rhs: External_TxOut) -> Bool {
    if lhs._amount != rhs._amount {return false}
    if lhs._targetKey != rhs._targetKey {return false}
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs._eFogHint != rhs._eFogHint {return false}
    if lhs._eMemo != rhs._eMemo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_TxIn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TxIn"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ring"),
    2: .same(proto: "proofs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ring) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.proofs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ring.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ring, fieldNumber: 1)
    }
    if !self.proofs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.proofs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_TxIn, rhs: External_TxIn) -> Bool {
    if lhs.ring != rhs.ring {return false}
    if lhs.proofs != rhs.proofs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_TxPrefix: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TxPrefix"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputs"),
    2: .same(proto: "outputs"),
    3: .same(proto: "fee"),
    4: .standard(proto: "tombstone_block"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.fee) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.tombstoneBlock) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 1)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 2)
    }
    if self.fee != 0 {
      try visitor.visitSingularUInt64Field(value: self.fee, fieldNumber: 3)
    }
    if self.tombstoneBlock != 0 {
      try visitor.visitSingularUInt64Field(value: self.tombstoneBlock, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_TxPrefix, rhs: External_TxPrefix) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.tombstoneBlock != rhs.tombstoneBlock {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_RingMLSAG: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RingMLSAG"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "c_zero"),
    2: .same(proto: "responses"),
    3: .standard(proto: "key_image"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cZero) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.responses) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._keyImage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cZero {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.responses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responses, fieldNumber: 2)
    }
    try { if let v = self._keyImage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_RingMLSAG, rhs: External_RingMLSAG) -> Bool {
    if lhs._cZero != rhs._cZero {return false}
    if lhs.responses != rhs.responses {return false}
    if lhs._keyImage != rhs._keyImage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_SignatureRctBulletproofs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignatureRctBulletproofs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ring_signatures"),
    2: .standard(proto: "pseudo_output_commitments"),
    3: .standard(proto: "range_proofs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ringSignatures) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.pseudoOutputCommitments) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.rangeProofs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ringSignatures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ringSignatures, fieldNumber: 1)
    }
    if !self.pseudoOutputCommitments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pseudoOutputCommitments, fieldNumber: 2)
    }
    if !self.rangeProofs.isEmpty {
      try visitor.visitSingularBytesField(value: self.rangeProofs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_SignatureRctBulletproofs, rhs: External_SignatureRctBulletproofs) -> Bool {
    if lhs.ringSignatures != rhs.ringSignatures {return false}
    if lhs.pseudoOutputCommitments != rhs.pseudoOutputCommitments {return false}
    if lhs.rangeProofs != rhs.rangeProofs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_Tx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Tx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prefix"),
    2: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._prefix) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prefix {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_Tx, rhs: External_Tx) -> Bool {
    if lhs._prefix != rhs._prefix {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_TxHash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TxHash"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_TxHash, rhs: External_TxHash) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_Receipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Receipt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .same(proto: "confirmation"),
    3: .standard(proto: "tombstone_block"),
    4: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._confirmation) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.tombstoneBlock) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._confirmation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.tombstoneBlock != 0 {
      try visitor.visitSingularUInt64Field(value: self.tombstoneBlock, fieldNumber: 3)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_Receipt, rhs: External_Receipt) -> Bool {
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs._confirmation != rhs._confirmation {return false}
    if lhs.tombstoneBlock != rhs.tombstoneBlock {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_VerificationSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VerificationSignature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contents"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.contents) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contents.isEmpty {
      try visitor.visitSingularBytesField(value: self.contents, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_VerificationSignature, rhs: External_VerificationSignature) -> Bool {
    if lhs.contents != rhs.contents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension External_VerificationReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VerificationReport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sig"),
    2: .same(proto: "chain"),
    3: .standard(proto: "http_body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sig) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.chain) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.httpBody) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.chain.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.chain, fieldNumber: 2)
    }
    if !self.httpBody.isEmpty {
      try visitor.visitSingularStringField(value: self.httpBody, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: External_VerificationReport, rhs: External_VerificationReport) -> Bool {
    if lhs._sig != rhs._sig {return false}
    if lhs.chain != rhs.chain {return false}
    if lhs.httpBody != rhs.httpBody {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
