// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ledger.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2018-2021 MobileCoin Inc.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

//// The logical result of an individual index in a GetOutputs request
public enum FogLedger_OutputResultCode: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  //// The default value for fixed32 is intentionally unused to avoid omitting this field
  case intentionallyUnused // = 0

  //// A TxOut with this index was not found in the ledger (it is out of bounds)
  case doesNotExist // = 1

  //// A TxOut with this index was found and the output and merkle-proof are provided
  case exists // = 2

  //// A database error prevented us from satisfying the request
  case outputDatabaseError // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .intentionallyUnused
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .intentionallyUnused
    case 1: self = .doesNotExist
    case 2: self = .exists
    case 3: self = .outputDatabaseError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .intentionallyUnused: return 0
    case .doesNotExist: return 1
    case .exists: return 2
    case .outputDatabaseError: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension FogLedger_OutputResultCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FogLedger_OutputResultCode] = [
    .intentionallyUnused,
    .doesNotExist,
    .exists,
    .outputDatabaseError,
  ]
}

#endif  // swift(>=4.2)

//// The result code indicating whether the spent_at block was found.
public enum FogLedger_KeyImageResultCode: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  //// The default value for fixed32 is intentionally unused to avoid omitting this field.
  case unused // = 0

  //// The key image has been spent, and the spent_at value was found.
  case spent // = 1

  //// The key image has not been spent.
  case notSpent // = 2

  //// Error occurred when getting key image
  case keyImageError // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unused
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unused
    case 1: self = .spent
    case 2: self = .notSpent
    case 3: self = .keyImageError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unused: return 0
    case .spent: return 1
    case .notSpent: return 2
    case .keyImageError: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension FogLedger_KeyImageResultCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FogLedger_KeyImageResultCode] = [
    .unused,
    .spent,
    .notSpent,
    .keyImageError,
  ]
}

#endif  // swift(>=4.2)

public enum FogLedger_TxOutResultCode: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case notFound // = 0
  case found // = 1
  case malformedRequest // = 2
  case databaseError // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .notFound
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notFound
    case 1: self = .found
    case 2: self = .malformedRequest
    case 3: self = .databaseError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notFound: return 0
    case .found: return 1
    case .malformedRequest: return 2
    case .databaseError: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension FogLedger_TxOutResultCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FogLedger_TxOutResultCode] = [
    .notFound,
    .found,
    .malformedRequest,
    .databaseError,
  ]
}

#endif  // swift(>=4.2)

public struct FogLedger_GetOutputsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The global txout indices being requested
  public var indices: [UInt64] = []

  //// The common merkle-root block that all the proofs should share
  public var merkleRootBlock: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FogLedger_GetOutputsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The outputs that we found
  public var results: [FogLedger_OutputResult] = []

  //// The total number of blocks in the ledger at the time the request is evaluated
  public var numBlocks: UInt64 = 0

  //// The total number of Txos in the ledger at the time the request is evaluated
  public var globalTxoCount: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FogLedger_OutputResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The global txout index that was queried
  public var index: UInt64 = 0

  //// A status code indicating the result of the query
  //// This is fixed32 to avoid leaking information about found / not found
  //// in the size of the encrypted payload.
  //// The possible values are described in enum OutputResultCode
  public var resultCode: UInt32 = 0

  //// The output that we found
  public var output: External_TxOut {
    get {return _output ?? External_TxOut()}
    set {_output = newValue}
  }
  /// Returns true if `output` has been explicitly set.
  public var hasOutput: Bool {return self._output != nil}
  /// Clears the value of `output`. Subsequent reads from it will return its default value.
  public mutating func clearOutput() {self._output = nil}

  //// The merkle proof for that output
  public var proof: External_TxOutMembershipProof {
    get {return _proof ?? External_TxOutMembershipProof()}
    set {_proof = newValue}
  }
  /// Returns true if `proof` has been explicitly set.
  public var hasProof: Bool {return self._proof != nil}
  /// Clears the value of `proof`. Subsequent reads from it will return its default value.
  public mutating func clearProof() {self._proof = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _output: External_TxOut? = nil
  fileprivate var _proof: External_TxOutMembershipProof? = nil
}

public struct FogLedger_CheckKeyImagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// A list of key images queries, to check if they have appeared in the ledger
  //// already, and if so, in what block.
  public var queries: [FogLedger_KeyImageQuery] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FogLedger_KeyImageQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The key image to check.
  public var keyImage: External_KeyImage {
    get {return _keyImage ?? External_KeyImage()}
    set {_keyImage = newValue}
  }
  /// Returns true if `keyImage` has been explicitly set.
  public var hasKeyImage: Bool {return self._keyImage != nil}
  /// Clears the value of `keyImage`. Subsequent reads from it will return its default value.
  public mutating func clearKeyImage() {self._keyImage = nil}

  //// An optional start_block to start searching forward from when performing the check.
  ////
  //// Note:
  //// A correct implementation of the server may ignore this, it is an optimization.
  //// This may help scaling because then for daily active users we won't have to
  //// obliviously scan the whole set to support their queries.
  public var startBlock: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _keyImage: External_KeyImage? = nil
}

//// A response to a request for key image checks
////
//// Contracts:
//// If a KeyImageResult comes back with spent_at != 0, then it was spent in that block index.
//// If a KeyImageResult comes back with spent_at == 0, then it was NOT spent, AT LEAST as of
//// resp.block_height (the top level block height number). It is possible that it WAS actually
//// spent in resp.block_height + 1, but the server didn't know, or didn't figure that out.
public struct FogLedger_CheckKeyImagesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The number of blocks in the ledger at the time that the request was evaluated.
  ////
  //// Note: This may be a conservative estimate, in the sense of being a lower bound.
  //// It's allowed that the data is "more fresh" than we are telling the client, but not less fresh.
  ////
  //// Implementation note: If the server does not evaluate all the key image checks as one
  //// database transaction, then this number should be a lower bound on the num_blocks across
  //// all of those database transactions.
  public var numBlocks: UInt64 = 0

  //// The number of txos in the ledger at the time that the request was evaluated.
  public var globalTxoCount: UInt64 = 0

  //// The results for each key image query
  public var results: [FogLedger_KeyImageResult] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FogLedger_KeyImageResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The key image that was queried.
  public var keyImage: External_KeyImage {
    get {return _keyImage ?? External_KeyImage()}
    set {_keyImage = newValue}
  }
  /// Returns true if `keyImage` has been explicitly set.
  public var hasKeyImage: Bool {return self._keyImage != nil}
  /// Clears the value of `keyImage`. Subsequent reads from it will return its default value.
  public mutating func clearKeyImage() {self._keyImage = nil}

  //// The block index at which it was spent.
  //// Note, spent_at is only valid if key_image_result_code == Spent. If
  //// key_image_result_code is not Spent, then spent_at is undefined, but > 0.
  public var spentAt: UInt64 = 0

  //// The timestamp of the block containing this key image.
  //// The value is u64::MAX if the timestamp cannot be found.
  //// If the timestamp cannot be found, even when key_image_result_code == Spent,
  //// that represents an internal error of the server
  //// which should be reported to the developers.
  //// Note: The timestamps are based on untrusted reporting of time from the consensus validators.
  //// Represented as seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z.
  public var timestamp: UInt64 = 0

  //// The result code indicating whether the timestamp was found, can be tried again later, or will
  //// never be found with the current configuration of the Key Image Service's watcher.
  //// This is fixed32 to avoid leaking information about found / not found in the size of the encrypted
  //// payload.
  //// The possible values are described in enum TimestampResultCode.
  //// This is a legacy result code which was forwarded by ledger server from the Watcher db API if a timestamp is not available.
  //// The ledger server now handles all of these errors and the result will always be `TimestampFound`.
  //// Clients should ignore this value, and in a future revision we may make it always zero.
  public var timestampResultCode: UInt32 = 0

  //// The result code indicating whether the key image was spent.
  //// The possible values are described in enum KeyImageResultCode.
  public var keyImageResultCode: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _keyImage: External_KeyImage? = nil
}

public struct FogLedger_BlockRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// A request formulated as several ranges of block indices
  public var ranges: [FogCommon_BlockRange] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FogLedger_BlockResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The block data returned by the server
  public var blocks: [FogLedger_BlockData] = []

  //// The total number of blocks in the ledger at the time the request is evaluated
  public var numBlocks: UInt64 = 0

  //// The total number of Txos in the ledger at the time the request is evaluated
  public var globalTxoCount: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FogLedger_BlockData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The index of the block in the blockchain
  public var index: UInt64 = 0

  //// The cumulative number of Txos in the blockchain, including this block
  public var globalTxoCount: UInt64 = 0

  //// The TxOuts of this block in consecutive order
  public var outputs: [External_TxOut] = []

  //// The timestamp of the block (if timestamp is available)
  public var timestamp: UInt64 = 0

  //// Indicates if the block had a timestamp
  //// The possible values are described in enum TimestampResultCode.
  public var timestampResultCode: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FogLedger_TxOutRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The TxOut.pubkey (compressed ristretto point bytes) of interest
  //// This is repeated so that several logical queries can be bundled into one
  //// grpc request.
  public var txOutPubkeys: [External_CompressedRistretto] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FogLedger_TxOutResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The results corresponding to each tx_out_pubkey request
  public var results: [FogLedger_TxOutResult] = []

  //// The total number of blocks in the ledger at the time the request is evaluated
  //// tx_out_pubkeys which are NotFound are guaranteed not to have appeared in the blockchain
  //// in any block of index less than this value.
  public var numBlocks: UInt64 = 0

  //// The total number of Txos in the ledger at the time the request is evaluated
  public var globalTxoCount: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FogLedger_TxOutResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The query that this result corresponds to
  public var txOutPubkey: External_CompressedRistretto {
    get {return _txOutPubkey ?? External_CompressedRistretto()}
    set {_txOutPubkey = newValue}
  }
  /// Returns true if `txOutPubkey` has been explicitly set.
  public var hasTxOutPubkey: Bool {return self._txOutPubkey != nil}
  /// Clears the value of `txOutPubkey`. Subsequent reads from it will return its default value.
  public mutating func clearTxOutPubkey() {self._txOutPubkey = nil}

  //// A status code indicating the result of the query
  public var resultCode: FogLedger_TxOutResultCode = .notFound

  //// The global index of this tx out (if found)
  public var txOutGlobalIndex: UInt64 = 0

  //// The block index of this tx out (if found)
  public var blockIndex: UInt64 = 0

  //// The timestamp of the block of this tx out (if found and timestamp is available)
  public var timestamp: UInt64 = 0

  //// Indicates if the block had a timestamp (if tx out was found)
  //// The possible values are described in enum TimestampResultCode.
  public var timestampResultCode: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _txOutPubkey: External_CompressedRistretto? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "fog_ledger"

extension FogLedger_OutputResultCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IntentionallyUnused"),
    1: .same(proto: "DoesNotExist"),
    2: .same(proto: "Exists"),
    3: .same(proto: "OutputDatabaseError"),
  ]
}

extension FogLedger_KeyImageResultCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Unused"),
    1: .same(proto: "Spent"),
    2: .same(proto: "NotSpent"),
    3: .same(proto: "KeyImageError"),
  ]
}

extension FogLedger_TxOutResultCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NotFound"),
    1: .same(proto: "Found"),
    2: .same(proto: "MalformedRequest"),
    3: .same(proto: "DatabaseError"),
  ]
}

extension FogLedger_GetOutputsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOutputsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "indices"),
    2: .standard(proto: "merkle_root_block"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFixed64Field(value: &self.indices) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.merkleRootBlock) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.indices.isEmpty {
      try visitor.visitPackedFixed64Field(value: self.indices, fieldNumber: 1)
    }
    if self.merkleRootBlock != 0 {
      try visitor.visitSingularFixed64Field(value: self.merkleRootBlock, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_GetOutputsRequest, rhs: FogLedger_GetOutputsRequest) -> Bool {
    if lhs.indices != rhs.indices {return false}
    if lhs.merkleRootBlock != rhs.merkleRootBlock {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_GetOutputsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOutputsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "results"),
    2: .standard(proto: "num_blocks"),
    3: .standard(proto: "global_txo_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.numBlocks) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.globalTxoCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 1)
    }
    if self.numBlocks != 0 {
      try visitor.visitSingularUInt64Field(value: self.numBlocks, fieldNumber: 2)
    }
    if self.globalTxoCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.globalTxoCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_GetOutputsResponse, rhs: FogLedger_GetOutputsResponse) -> Bool {
    if lhs.results != rhs.results {return false}
    if lhs.numBlocks != rhs.numBlocks {return false}
    if lhs.globalTxoCount != rhs.globalTxoCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_OutputResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutputResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .standard(proto: "result_code"),
    3: .same(proto: "output"),
    4: .same(proto: "proof"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.resultCode) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._output) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._proof) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.index != 0 {
      try visitor.visitSingularFixed64Field(value: self.index, fieldNumber: 1)
    }
    if self.resultCode != 0 {
      try visitor.visitSingularFixed32Field(value: self.resultCode, fieldNumber: 2)
    }
    try { if let v = self._output {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._proof {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_OutputResult, rhs: FogLedger_OutputResult) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.resultCode != rhs.resultCode {return false}
    if lhs._output != rhs._output {return false}
    if lhs._proof != rhs._proof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_CheckKeyImagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckKeyImagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "queries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.queries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.queries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.queries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_CheckKeyImagesRequest, rhs: FogLedger_CheckKeyImagesRequest) -> Bool {
    if lhs.queries != rhs.queries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_KeyImageQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeyImageQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_image"),
    2: .standard(proto: "start_block"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keyImage) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.startBlock) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyImage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.startBlock != 0 {
      try visitor.visitSingularFixed64Field(value: self.startBlock, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_KeyImageQuery, rhs: FogLedger_KeyImageQuery) -> Bool {
    if lhs._keyImage != rhs._keyImage {return false}
    if lhs.startBlock != rhs.startBlock {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_CheckKeyImagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckKeyImagesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_blocks"),
    2: .standard(proto: "global_txo_count"),
    3: .same(proto: "results"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.numBlocks) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.globalTxoCount) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numBlocks != 0 {
      try visitor.visitSingularUInt64Field(value: self.numBlocks, fieldNumber: 1)
    }
    if self.globalTxoCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.globalTxoCount, fieldNumber: 2)
    }
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_CheckKeyImagesResponse, rhs: FogLedger_CheckKeyImagesResponse) -> Bool {
    if lhs.numBlocks != rhs.numBlocks {return false}
    if lhs.globalTxoCount != rhs.globalTxoCount {return false}
    if lhs.results != rhs.results {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_KeyImageResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeyImageResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_image"),
    2: .standard(proto: "spent_at"),
    3: .same(proto: "timestamp"),
    4: .standard(proto: "timestamp_result_code"),
    5: .standard(proto: "key_image_result_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keyImage) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.spentAt) }()
      case 3: try { try decoder.decodeSingularFixed64Field(value: &self.timestamp) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self.timestampResultCode) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self.keyImageResultCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyImage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.spentAt != 0 {
      try visitor.visitSingularFixed64Field(value: self.spentAt, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularFixed64Field(value: self.timestamp, fieldNumber: 3)
    }
    if self.timestampResultCode != 0 {
      try visitor.visitSingularFixed32Field(value: self.timestampResultCode, fieldNumber: 4)
    }
    if self.keyImageResultCode != 0 {
      try visitor.visitSingularFixed32Field(value: self.keyImageResultCode, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_KeyImageResult, rhs: FogLedger_KeyImageResult) -> Bool {
    if lhs._keyImage != rhs._keyImage {return false}
    if lhs.spentAt != rhs.spentAt {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.timestampResultCode != rhs.timestampResultCode {return false}
    if lhs.keyImageResultCode != rhs.keyImageResultCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_BlockRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ranges"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ranges) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ranges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ranges, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_BlockRequest, rhs: FogLedger_BlockRequest) -> Bool {
    if lhs.ranges != rhs.ranges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_BlockResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blocks"),
    2: .standard(proto: "num_blocks"),
    3: .standard(proto: "global_txo_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.blocks) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.numBlocks) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.globalTxoCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 1)
    }
    if self.numBlocks != 0 {
      try visitor.visitSingularUInt64Field(value: self.numBlocks, fieldNumber: 2)
    }
    if self.globalTxoCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.globalTxoCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_BlockResponse, rhs: FogLedger_BlockResponse) -> Bool {
    if lhs.blocks != rhs.blocks {return false}
    if lhs.numBlocks != rhs.numBlocks {return false}
    if lhs.globalTxoCount != rhs.globalTxoCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_BlockData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .standard(proto: "global_txo_count"),
    3: .same(proto: "outputs"),
    4: .same(proto: "timestamp"),
    5: .standard(proto: "timestamp_result_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.globalTxoCount) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.timestampResultCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt64Field(value: self.index, fieldNumber: 1)
    }
    if self.globalTxoCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.globalTxoCount, fieldNumber: 2)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    if self.timestampResultCode != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestampResultCode, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_BlockData, rhs: FogLedger_BlockData) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.globalTxoCount != rhs.globalTxoCount {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.timestampResultCode != rhs.timestampResultCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_TxOutRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TxOutRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_out_pubkeys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.txOutPubkeys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txOutPubkeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.txOutPubkeys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_TxOutRequest, rhs: FogLedger_TxOutRequest) -> Bool {
    if lhs.txOutPubkeys != rhs.txOutPubkeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_TxOutResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TxOutResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "results"),
    2: .standard(proto: "num_blocks"),
    3: .standard(proto: "global_txo_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.numBlocks) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.globalTxoCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 1)
    }
    if self.numBlocks != 0 {
      try visitor.visitSingularUInt64Field(value: self.numBlocks, fieldNumber: 2)
    }
    if self.globalTxoCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.globalTxoCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_TxOutResponse, rhs: FogLedger_TxOutResponse) -> Bool {
    if lhs.results != rhs.results {return false}
    if lhs.numBlocks != rhs.numBlocks {return false}
    if lhs.globalTxoCount != rhs.globalTxoCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_TxOutResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TxOutResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_out_pubkey"),
    2: .standard(proto: "result_code"),
    3: .standard(proto: "tx_out_global_index"),
    4: .standard(proto: "block_index"),
    5: .same(proto: "timestamp"),
    6: .standard(proto: "timestamp_result_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._txOutPubkey) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.resultCode) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.txOutGlobalIndex) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.blockIndex) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.timestampResultCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._txOutPubkey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.resultCode != .notFound {
      try visitor.visitSingularEnumField(value: self.resultCode, fieldNumber: 2)
    }
    if self.txOutGlobalIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.txOutGlobalIndex, fieldNumber: 3)
    }
    if self.blockIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockIndex, fieldNumber: 4)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 5)
    }
    if self.timestampResultCode != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestampResultCode, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_TxOutResult, rhs: FogLedger_TxOutResult) -> Bool {
    if lhs._txOutPubkey != rhs._txOutPubkey {return false}
    if lhs.resultCode != rhs.resultCode {return false}
    if lhs.txOutGlobalIndex != rhs.txOutGlobalIndex {return false}
    if lhs.blockIndex != rhs.blockIndex {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.timestampResultCode != rhs.timestampResultCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
